# Frustum Culling is a subtle but extremely important part of your game. This class is designed to provide
# you with several methods of detecting whether a set of polygons are visible to the user; if they're not
# visible, then you can safely skip rendering them. This leads to vast increases in framerate, even if you
# do no further optimization.
#
# Ideally, you'd combine this with an OpenGl::Octree for even more efficient culling.
#
# Some of the tests made available to you by the Frustum class may return the symbol :partial instead of
# true or false. You can safely evaluate :partial to mean "true" -- but this distinction is made for highly
# optimized pieces of code that rely on whether the object is fully or partially within the Frustum. For instance,
# OpenGl::Octree uses the :partial response to determine whether to assume that all objects within the Octree
# are visible. Methods that may return :partial will return true when the object is entirely within the Frustum,
# and :partial when the object is only partially in the Frustum.
#
# You should call #update! whenever you change the OpenGL matrix (unless you don't intend to test against it)
# so that the Frustum is not out-of-date. Note that this is done automatically by the Camera class when you
# call Camera#look! -- so if you're checking against a Frustum instantiated and managed by the Camera class,
# then updating it would be redundant. Frustum#update! is an expensive call, so you want to do it as rarely
# as you can manage.
#
class OpenGl::Frustum
  include Helpers::XyzHelper
  include Geometry
  SIDES = [ :right, :left, :top, :bottom, :near, :far ]

  attr_reader :planes#, :modelview

  def initialize
    @planes = { }
    #@modelview = Array.new(16) { 0.0 }
    #@clip = Array.new(16) { 0.0 }
    SIDES.each { |k| @planes[k] = Plane.new }
  end

  # Returns true if the specified point is in the frustum; false otherwise.
  def point_visible?(*point)
    __point_visible?(*(point.extract_vector3i!))
  end

  # Returns true if the specified sphere is completely within the frustum;
  # returns :partial if the sphere is only partially within the frustum;
  # returns false if the sphere is completely outside the frustum.
  def sphere_visible?(radius, *point)
    __sphere_visible?(radius, *(point.extract_vector3i!))
  end

  #
  # There are many ways to call #cube_visible? and all of them depend on just how much you know about the
  # cube in question.
  #
  # Size can be either a scalar, in which case the cube is treated as a perfect square cube, or a Vector3d,
  # in which x, y and z represent width, height and depth, respectively. These numbers should be from the
  # origin (center) of the object, so divide by two if you're working with the entire size.
  #
  # *point can be either 3 scalars, which are assumed to be position x, y, z, in which case the view, up and
  # right vectors are assumed to be (0,0,-1), (0,1,0) and (1,0,0), respectively;
  #
  # or *point can be a set of 4 Vector3d's, in which case they are expected to be:
  #
  #   origin, view_vector, up_vector, right_vector - in that order.
  #
  # The extents of the bounding box will be calculated based on these vectors and the
  # supplied size(s) by calling #bounding_box.
  #
  # Or, you can pass a set of 8 Vector3d's, in which case they are interpreted as the transformed worldspace
  # coordinates of the bounding box to be tested. This would prevent #bounding_box from being called, which
  # may be ideal if the object's transformations are not changing very often. The order of vertices in this
  # list does not matter.
  #
  # Examples:
  #   # a width, height, depth of 5, 5, 5 at world position 0,0,0
  #   1. frustum.cube_visible? 5, 0, 0, 0
  #   #
  #   # a width, height, depth of 1, 2, 3 at world position 4,5,6
  #   2. frustum.cube_visible? 1, 2, 3, 4, 5, 6
  #   #
  #   # Generates a bounding box with the following arguments, see #bounding_box(w, h, d, p, v, u, r)
  #   # note that for optimization you should really cache this yourself and update it when necessary
  #   3. frustum.cube_visible? width, height, depth, position, view, up, right
  #   #
  #   # check a preset bounding box
  #   4. frustum.cube_visible? front_top_left, front_top_right, front_bottom_left, front_bottom_right,
  #                         rear_top_left, rear_top_right, rear_bottom_left, rear_bottom_right
  #   #
  #   # check a bounding box generated by the frustum. Same as #3.
  #   5. frustum.cube_visible? frustum.bounding_box(. . .)
  # 
  # If the cube is completely within the frustum, returns true.
  # If the cube is partially within the frustum, returns :partial.
  # Else, returns false.
  #
  def cube_visible?(size, *point)
    corners = if point.length == 7 or (size.kind_of? Array and point.length == 0)
      corners = [size]
      corners.concat point
      corners.flatten!
    else
      w, h, d = (size.kind_of? Array) ? size : (size.kind_of? Vertex3d) ? size.to_a : [size, size, size]
      position, view, up, right = case point.length
        when 3 then [Vertex3d.new(*point), Vertex3d.new(0,0,-1), Vertex3d.new(0,1,0), Vertex3d.new(1,0,0)]
        else point
      end

      raise "Could not calculate width, height and depth from arguments: #{size.inspect}, #{point.inspect}" unless
              w and h and d
      raise "Could not calculate position, view, up and right vectors from arguments: #{size}, #{point.inspect}" unless
              position and view and up and right
      
      bounding_box(w, h, d, position, view, up, right)
    end
    raise "Could not calculate any bounding box vertices from arguments: #{size}, #{point.inspect}" if corners.empty?

    __cube_visible?(corners)
  end

  # to be optimized
  def each_plane
    #warn "optimize me"
    left = planes.keys
    right = planes.values
    yield left[0], right[0]
    yield left[1], right[1]
    yield left[2], right[2]
    yield left[3], right[3]
    yield left[4], right[4]
    yield left[5], right[5]
  end

  # Returns the eight points that make up a bounding box calculated from the specified
  # width, height, depth, position, view, up and right vectors (in that order).
  # This is best used to buffer the bounding box in memory so that it doesn't have to be
  # calculated every time #cube_visible? is called (which would be the default functionality).
  #
  # The view, up, and right vectors must be normalized for the results to be accurate.
  # The position vector should be in worldspace.
  # The actual width, height and depth of the bounding box will be equal to 2 times the
  # supplied width, height and depth.  
  def self.bounding_box(box_array, w, h, d, position, view, up, right)
    box_array[0] = ( view*d +  up*h + -right*w + position)    # front, top,    left
    box_array[1] = ( view*d +  up*h +  right*w + position)    # front, top,    right
    box_array[2] = ( view*d + -up*h + -right*w + position)    # front, bottom, left
    box_array[3] = ( view*d + -up*h +  right*w + position)    # front, bottom, right
    box_array[4] = (-view*d +  up*h + -right*w + position)    # rear,  top,    left
    box_array[5] = (-view*d +  up*h +  right*w + position)    # rear,  top,    right
    box_array[6] = (-view*d + -up*h + -right*w + position)    # rear,  bottom, left
    box_array[7] = (-view*d + -up*h +  right*w + position)    # rear,  bottom, right
    box_array
  end

  # Returns true if the specified polygon is within the frustum, false otherwise.
  def poly_visible?(*vertices)
    __poly_visible?(*vertices)
  end

  alias polygon_visible? poly_visible?

  SIDES.each { |k| eval("def #{k}; @planes[#{k.inspect}]; end", binding, __FILE__, __LINE__)}

  private
  def normalize_planes!
    planes.each { |side, plane| plane.normalize! }
  end
end
